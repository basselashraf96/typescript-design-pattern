<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OOP Principles in TypeScript</title>
    <link rel="stylesheet" href="../css/styles.css">
</head>

<body>

    <!-- üîπ Header Navigation -->
    <header class="header">
        <h1 class="logo">OOP Principles</h1>
        <nav>
            <ul class="nav-links">
                <li><a href="../index.html">üè† Home</a></li>
                <li><a href="oop.html" aria-current="page">üé≠ OOP Principles</a></li>
                <li><a href="solid.html">üõ†Ô∏è SOLID Principles</a></li>
            </ul>
        </nav>
    </header>

    <main class="content"></main>
    <h2>üé≠ Object-Oriented Programming (OOP) Principles</h2>
    <p>OOP is a programming paradigm based on <strong>four key principles</strong> that make code reusable, modular, and
        scalable.</p>

    <section class="accordion">
        <!-- 1Ô∏è‚É£ Abstraction -->
        <article class="accordion-item">
            <button class="accordion-header" aria-expanded="false" aria-controls="abstraction-content">üîç
                Abstraction</button>
            <div id="abstraction-content" class="accordion-content" hidden>
                <p>Abstraction hides implementation details and exposes only the necessary parts.</p>
                <p><strong>Analogy:</strong> A car‚Äôs steering wheel hides the internal engine complexities. You only
                    interact with the interface (steering, gas pedal).</p>
                <pre><code>
abstract class Animal {
    abstract makeSound(): void;
}

class Dog extends Animal {
    makeSound(): void {
        console.log("Woof!");
    }
}

const myDog = new Dog();
myDog.makeSound(); // Woof!
                    </code></pre>
            </div>
        </article>

        <!-- 2Ô∏è‚É£ Encapsulation -->
        <article class="accordion-item">
            <button class="accordion-header" aria-expanded="false" aria-controls="encapsulation-content">üîí
                Encapsulation</button>
            <div id="encapsulation-content" class="accordion-content" hidden>
                <p>Encapsulation restricts direct access to object data and ensures controlled modification.</p>
                <p><strong>Analogy:</strong> A bank account keeps your balance private, but allows deposits and
                    withdrawals through secure methods.</p>
                <pre><code>
class BankAccount {
    private balance: number;

    constructor(initialBalance: number) {
        this.balance = initialBalance;
    }

    deposit(amount: number): void {
        this.balance += amount;
    }

    getBalance(): number {
        return this.balance;
    }
}
                    </code></pre>
            </div>
        </article>

        <!-- 3Ô∏è‚É£ Inheritance -->
        <article class="accordion-item">
            <button class="accordion-header" aria-expanded="false" aria-controls="inheritance-content">üìú
                Inheritance</button>
            <div id="inheritance-content" class="accordion-content" hidden>
                <p>Inheritance allows one class to inherit properties and methods from another.</p>
                <p><strong>Analogy:</strong> A child inherits features from their parents, but can also have unique
                    traits.</p>
                <pre><code>
class Person {
    constructor(public name: string) {}
}

class Employee extends Person {
    constructor(name: string, public jobTitle: string) {
        super(name);
    }
}

const emp = new Employee("Alice", "Developer");
console.log(emp.name, emp.jobTitle);
                    </code></pre>
            </div>
        </article>

        <!-- 4Ô∏è‚É£ Polymorphism -->
        <article class="accordion-item">
            <button class="accordion-header" aria-expanded="false" aria-controls="polymorphism-content">üé≠
                Polymorphism</button>
            <div id="polymorphism-content" class="accordion-content" hidden>
                <p>Polymorphism allows different classes to be treated as the same type.</p>
                <p><strong>Analogy:</strong> A universal remote works for different TVs because they follow a common
                    standard.</p>
                <pre>
                    <code>
interface Animal {
    makeSound(): void;
}

class Cat implements Animal {
    makeSound(): void {
        console.log("Meow!");
    }
}

const cat: Animal = new Cat();
cat.makeSound(); // Meow!
                    </code>
                </pre>
            </div>
        </article>
    </section>
    </div>
    </main>

    <script src="../js/script.js"></script>
</body>

</html>